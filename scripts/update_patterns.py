#!/usr/bin/env python3
"""
Update PATTERNS.md with newly extracted patterns

This script reads PATTERNS.md, adds new patterns, updates existing ones,
and maintains pattern statistics.
"""

import re
from datetime import datetime

from pattern_extractor import Pattern, PatternCategory


class PatternDocUpdater:
    """Updates PATTERNS.md with new patterns"""

    def __init__(self, patterns_file: str = "PATTERNS.md"):
        self.patterns_file = patterns_file
        self.content = self._read_file()

    def _read_file(self) -> str:
        """Read current PATTERNS.md content"""
        try:
            with open(self.patterns_file) as f:
                return f.read()
        except FileNotFoundError:
            # Return template if file doesn't exist
            return self._get_template()

    def _get_template(self) -> str:
        """Get PATTERNS.md template"""
        return """# User Patterns & Preferences

**Auto-generated by /learn command from interaction analysis**

## Overview

This document captures implicit patterns, preferences, and contextual behaviors learned from user interactions.

## Pattern Confidence Levels

- ðŸŸ¢ **High Confidence** (90%+): Seen 5+ times, consistently applied
- ðŸŸ¡ **Medium Confidence** (70-89%): Seen 3-4 times, mostly consistent
- ðŸ”´ **Low Confidence** (50-69%): Seen 1-2 times, needs validation

---

## Code Style Patterns

<!-- Auto-populated by /learn -->

---

## Review Focus Patterns

<!-- Auto-populated by /learn -->

---

## Workflow Patterns

<!-- Auto-populated by /learn -->

---

## Communication Patterns

<!-- Auto-populated by /learn -->

---

## Error Recovery Patterns

<!-- Auto-populated by /learn -->

---

## Tool & Command Usage

<!-- Auto-populated by /learn -->

---

## Anti-Patterns

<!-- Auto-populated by /learn -->

---

## Pattern History

### Recently Added
<!-- Last 5 patterns detected -->

### Recently Updated
<!-- Patterns with changed confidence -->

### Under Review
<!-- Patterns needing validation -->

---

## Meta-Patterns

### Learning Velocity
- Patterns/week: <!-- Auto-calculated -->
- Correction frequency: <!-- Trending up/down -->
- Acceptance rate: <!-- % of suggestions accepted -->

### Pattern Distribution
- Style: <!-- % -->
- Quality: <!-- % -->
- Workflow: <!-- % -->
- Communication: <!-- % -->

---

*Last Updated: <!-- Auto-timestamp -->*
*Total Patterns: <!-- Count -->*
*Next Review: <!-- Scheduled analysis -->*
"""

    def add_pattern(self, pattern: Pattern) -> bool:
        """Add or update a pattern in the document"""
        section = self._find_section(pattern.category)
        if not section:
            return False

        # Check if pattern already exists
        existing = self._find_existing_pattern(pattern.name, section)

        if existing:
            # Update existing pattern
            self._update_existing_pattern(pattern, existing)
        else:
            # Add new pattern
            self._add_new_pattern(pattern, section)

        # Update metadata
        self._update_metadata(pattern)

        return True

    def _find_section(self, category: PatternCategory) -> dict | None:
        """Find the section for a pattern category"""
        section_start = self.content.find(f"## {category.value}")
        if section_start == -1:
            return None

        # Find next section
        next_section = self.content.find("\n## ", section_start + 1)
        if next_section == -1:
            next_section = self.content.find("\n---", section_start + 1)

        return {
            "start": section_start,
            "end": next_section if next_section != -1 else len(self.content),
            "content": self.content[
                section_start : next_section
                if next_section != -1
                else len(self.content)
            ],
        }

    def _find_existing_pattern(self, name: str, section: dict) -> dict | None:
        """Check if pattern already exists in section"""
        pattern_match = re.search(rf"### {re.escape(name)}\n", section["content"])
        if pattern_match:
            return {
                "start": section["start"] + pattern_match.start(),
                "match": pattern_match,
            }
        return None

    def _get_confidence_icon(self, confidence: float) -> str:
        """Get confidence icon based on value"""
        if confidence >= 0.9:
            return "ðŸŸ¢"
        if confidence >= 0.7:
            return "ðŸŸ¡"
        return "ðŸ”´"

    def _format_pattern(self, pattern: Pattern) -> str:
        """Format a pattern for markdown"""
        confidence_icon = self._get_confidence_icon(pattern.confidence)

        formatted = f"\n### {pattern.name}\n"
        formatted += f"**Confidence**: {confidence_icon} {pattern.confidence:.0%} (seen {pattern.occurrences}x)\n"
        formatted += f"**Description**: {pattern.description}\n"

        if pattern.evidence:
            formatted += "**Evidence**:\n"
            for evidence in pattern.evidence[:3]:  # Limit to 3 most recent
                formatted += (
                    f"- {evidence[:100]}{'...' if len(evidence) > 100 else ''}\n"
                )

        if pattern.triggers:
            formatted += f"**Triggers**: {', '.join(pattern.triggers)}\n"

        if pattern.actions:
            formatted += "**Actions**:\n"
            for action in pattern.actions:
                formatted += f"- {action}\n"

        if pattern.context:
            formatted += f"**Context**: {pattern.context}\n"

        if pattern.auto_apply:
            formatted += "**Auto-Apply**: âœ… Enabled\n"

        formatted += (
            f"**Last Seen**: {pattern.last_seen.strftime('%Y-%m-%d %H:%M')}\n\n"
        )

        return formatted

    def _add_new_pattern(self, pattern: Pattern, section: dict):
        """Add a new pattern to the section"""
        # Find where to insert (after section header, before next section)
        insert_point = section["content"].find("\n", section["content"].find("##")) + 1

        # Skip any existing description
        next_heading = section["content"].find("\n### ", insert_point)
        if next_heading == -1:
            # No patterns yet, find comment marker
            comment_marker = section["content"].find(
                "<!-- Auto-populated", insert_point
            )
            if comment_marker != -1:
                insert_point = (
                    section["content"].rfind("\n", insert_point, comment_marker) + 1
                )
        else:
            insert_point = next_heading

        formatted_pattern = self._format_pattern(pattern)

        # Insert into content
        absolute_insert = section["start"] + insert_point
        self.content = (
            self.content[:absolute_insert]
            + formatted_pattern
            + self.content[absolute_insert:]
        )

    def _update_existing_pattern(self, pattern: Pattern, existing: dict):
        """Update an existing pattern"""
        # Find the end of this pattern
        pattern_start = existing["start"]
        next_pattern = self.content.find("\n### ", pattern_start + 1)
        next_section = self.content.find("\n## ", pattern_start + 1)
        pattern_end = min(
            x for x in [next_pattern, next_section, len(self.content)] if x != -1
        )

        # Replace with updated pattern
        formatted_pattern = self._format_pattern(pattern)
        self.content = (
            self.content[:pattern_start]
            + formatted_pattern
            + self.content[pattern_end:]
        )

    def _update_metadata(self, pattern: Pattern):
        """Update document metadata"""
        # Update timestamp
        timestamp_pattern = r"\*Last Updated: .*\*"
        timestamp_replacement = (
            f"*Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M')}*"
        )
        self.content = re.sub(timestamp_pattern, timestamp_replacement, self.content)

        # Update recently added section
        recently_added = self.content.find("### Recently Added")
        if recently_added != -1:
            # Find insertion point
            insert_point = self.content.find("\n", recently_added) + 1
            next_heading = self.content.find("\n### ", insert_point)

            # Get current entries
            current_entries = self.content[insert_point:next_heading].strip()
            entries = [
                e.strip()
                for e in current_entries.split("\n")
                if e.strip() and not e.startswith("<!--")
            ]

            # Add new pattern
            new_entry = f"- {pattern.name} ({pattern.category.value}) - {datetime.now().strftime('%Y-%m-%d')}"
            entries.insert(0, new_entry)

            # Keep only last 5
            entries = entries[:5]

            # Update content
            self.content = (
                self.content[:insert_point]
                + "\n".join(entries)
                + "\n"
                + self.content[next_heading:]
            )

        # Update pattern count
        total_patterns = len(re.findall(r"^### [^#]", self.content, re.MULTILINE))
        self.content = re.sub(
            r"\*Total Patterns: .*\*",
            f"*Total Patterns: {total_patterns}*",
            self.content,
        )

    def save(self):
        """Save updated content to file"""
        with open(self.patterns_file, "w") as f:
            f.write(self.content)

    def get_statistics(self) -> dict:
        """Get pattern statistics"""
        stats = {
            "total": len(re.findall(r"^### [^#]", self.content, re.MULTILINE)),
            "by_category": {},
            "by_confidence": {"high": 0, "medium": 0, "low": 0},
        }

        # Count by category
        for category in PatternCategory:
            count = len(
                re.findall(
                    rf"## {category.value}.*?(?=## |\Z)", self.content, re.DOTALL
                )
            )
            stats["by_category"][category.value] = count

        # Count by confidence
        stats["by_confidence"]["high"] = len(re.findall(r"ðŸŸ¢", self.content))
        stats["by_confidence"]["medium"] = len(re.findall(r"ðŸŸ¡", self.content))
        stats["by_confidence"]["low"] = len(re.findall(r"ðŸ”´", self.content))

        return stats


def main():
    """Example usage"""
    from pattern_extractor import PatternExtractor

    # Extract patterns
    extractor = PatternExtractor()
    interaction = "No, actually always use f-strings instead of .format()"
    patterns = extractor.extract_patterns(interaction)

    # Update document
    updater = PatternDocUpdater()
    for pattern in patterns:
        updater.add_pattern(pattern)

    # Save and show stats
    updater.save()
    stats = updater.get_statistics()
    print(f"Updated PATTERNS.md - Total patterns: {stats['total']}")


if __name__ == "__main__":
    main()
